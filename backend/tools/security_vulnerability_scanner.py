import os
import subprocess
import sys
from typing import List, Tuple, Optional
import re


def run_command(command: List[str]) -> Tuple[int, str, str]:
    """
    Executes a shell command and returns the exit code, stdout, and stderr.

    Args:
        command: A list of strings representing the command and its arguments.

    Returns:
        A tuple containing the exit code, stdout, and stderr.
    """
    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdout, stderr = process.communicate()
        exit_code = process.returncode
        return exit_code, stdout, stderr
    except FileNotFoundError as e:
        return 1, "", f"Command not found: {e}"
    except Exception as e:
        return 1, "", f"An error occurred: {e}"


def analyze_requirements_txt(requirements_file: str) -> List[str]:
    """
    Analyzes a requirements.txt file and returns a list of installed packages and their versions.

    Args:
        requirements_file: The path to the requirements.txt file.

    Returns:
        A list of strings, where each string is a package name and version (e.g., "requests==2.28.1").
    """
    packages: List[str] = []
    try:
        with open(requirements_file, "r") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    packages.append(line)
    except FileNotFoundError:
        print(f"Error: requirements file not found at {requirements_file}")
    except Exception as e:
        print(f"An error occurred while reading the requirements file: {e}")
    return packages


def analyze_python_code(file_path: str, top_k: int = None, **kwargs) -> List[str]:
    """
    Analyzes a Python code file for potential security vulnerabilities.
    Currently, it performs basic checks for common vulnerabilities like:
    - Usage of `eval`
    - Usage of `pickle` without safeguards
    - Hardcoded passwords
    - SQL injection patterns (basic)

    Args:
        file_path: The path to the Python file.
        top_k: Optional limit for results (currently ignored, returns all vulnerabilities)
        **kwargs: Additional optional arguments (ignored for compatibility)

    Returns:
        A list of strings, where each string is a potential vulnerability found in the code.
    """
    vulnerabilities: List[str] = []
    try:
        with open(file_path, "r") as f:
            code = f.read()

            if "eval(" in code:
                vulnerabilities.append(f"Potential eval() usage in {file_path}")
            if "pickle.load(" in code and "except:" not in code:
                vulnerabilities.append(f"Unsafe pickle.load() usage in {file_path}")
            if re.search(r"(password|pwd)\s*=\s*[\"'].*[\"']", code, re.IGNORECASE):
                vulnerabilities.append(f"Hardcoded password in {file_path}")
            if re.search(r"SELECT\s*\*.*FROM", code, re.IGNORECASE) and "format(" in code:
                vulnerabilities.append(f"Potential SQL injection vulnerability in {file_path}")

    except FileNotFoundError:
        print(f"Error: File not found at {file_path}")
    except Exception as e:
        print(f"An error occurred while analyzing the file: {e}")

    return vulnerabilities


def run_bandit(target: str) -> List[str]:
    """
    Runs the Bandit security linter on the specified target (file or directory).

    Args:
        target: The path to the file or directory to scan.

    Returns:
        A list of strings, where each string is a Bandit finding.  Returns an empty list if Bandit fails.
    """
    try:
        exit_code, stdout, stderr = run_command(["bandit", "-r", target, "-f", "txt"])
        if exit_code == 0:
            return stdout.splitlines()
        else:
            print(f"Bandit scan failed with error:\n{stderr}")
            return []
    except Exception as e:
        print(f"An error occurred while running Bandit: {e}")
        return []


def run_safety(requirements_file: str) -> List[str]:
    """
    Runs the Safety tool to check for known vulnerabilities in dependencies.

    Args:
        requirements_file: The path to the requirements.txt file.

    Returns:
        A list of strings, where each string is a Safety finding. Returns an empty list if Safety fails.
    """

    try:
        exit_code, stdout, stderr = run_command(["safety", "check", "-r", requirements_file, "--full-report"])
        if exit_code == 0:
            return stdout.splitlines()
        else:
            print(f"Safety check failed with error:\n{stderr}")
            return []
    except Exception as e:
        print(f"An error occurred while running Safety: {e}")
        return []


def security_scan(target: str, requirements_file: Optional[str] = None) -> None:
    """
    Performs a comprehensive security scan of the specified target.

    Args:
        target: The path to the file or directory to scan.
        requirements_file:  Optional path to a requirements.txt file. If provided, dependency checks will be performed.
    """
    print(f"Starting security scan on {target}...")

    # 1. Bandit Scan
    print("\nRunning Bandit...")
    bandit_results = run_bandit(target)
    if bandit_results:
        print("Bandit findings:")
        for result in bandit_results:
            print(result)
    else:
        print("No Bandit findings or Bandit scan failed.")

    # 2. Static Code Analysis
    print("\nPerforming Static Code Analysis...")
    if os.path.isfile(target) and target.endswith(".py"):
        static_analysis_results = analyze_python_code(target)
        if static_analysis_results:
            print("Static Code Analysis findings:")
            for result in static_analysis_results:
                print(result)
        else:
            print("No Static Code Analysis findings.")
    elif os.path.isdir(target):
        for root, _, files in os.walk(target):
            for file in files:
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    static_analysis_results = analyze_python_code(file_path)
                    if static_analysis_results:
                        print(f"Static Code Analysis findings in {file_path}:")
                        for result in static_analysis_results:
                            print(result)
    else:
        print("Static Code Analysis skipped: Target is not a Python file or directory.")

    # 3. Dependency Check (Safety)
    if requirements_file:
        print("\nRunning Safety Dependency Check...")
        safety_results = run_safety(requirements_file)
        if safety_results:
            print("Safety findings:")
            for result in safety_results:
                print(result)
        else:
            print("No Safety findings or Safety check failed.")
    else:
        print("Dependency check skipped: No requirements file provided.")

    print("\nSecurity scan complete.")


if __name__ == "__main__":
    # Example Usage:
    # 1. Scan a single Python file:
    # security_scan("example.py")

    # 2. Scan a directory:
    # security_scan("my_project")

    # 3. Scan a directory with a requirements file:
    # security_scan("my_project", "requirements.txt")

    # Create a dummy example.py for testing
    with open("example.py", "w") as f:
        f.write("import os\n")
        f.write("password = 'P@$$wOrd'\n")
        f.write("os.system('ls -l')\n")
        f.write("eval(input('Enter something: '))")

    # Create a dummy requirements.txt for testing
    with open("requirements.txt", "w") as f:
        f.write("requests==2.28.1\n")
        f.write("Flask==2.2.2\n")

    security_scan(".", "requirements.txt")

    # Clean up dummy files
    os.remove("example.py")
    os.remove("requirements.txt")